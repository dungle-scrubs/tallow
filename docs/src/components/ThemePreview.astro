---
/**
 * Interactive theme preview for the landing page.
 * Renders a swatch strip and a Quick Start terminal widget whose colors
 * swap on hover via CSS custom properties. All theme data is resolved
 * at build time — no runtime file reads.
 */
import { readdirSync, readFileSync } from "node:fs";
import { join } from "node:path";
import { resolveThemeColors, type ThemeColors } from "../lib/resolve-theme";

interface ThemeEntry {
	name: string;
	swatchBg: string;
	colors: ThemeColors;
}

/* Build-time: read all theme JSONs and resolve semantic tokens to hex values */
const themesDir = join(process.cwd(), "..", "themes");
const themeFiles = readdirSync(themesDir)
	.filter((file) => file.endsWith(".json"))
	.sort();

const themeData: ThemeEntry[] = themeFiles.map((file) => {
	const raw = readFileSync(join(themesDir, file), "utf-8");
	const theme = JSON.parse(raw) as { name?: string };
	const colors = resolveThemeColors(theme);
	return {
		name: typeof theme.name === "string" && theme.name.length > 0 ? theme.name : file,
		swatchBg: colors.bg,
		colors,
	};
});

if (themeData.length === 0) {
	throw new Error("No themes found in themes directory");
}

const defaultColors = themeData[0].colors;

/** Color arrays for the client script — no names needed at runtime. */
const clientData = themeData.map((t) => t.colors);
---

<div
	class="theme-preview not-content"
	style={`--qs-bg:${defaultColors.bg};--qs-bg-dark:${defaultColors.bgDark};--qs-border:${defaultColors.border};--qs-text:${defaultColors.text};--qs-muted:${defaultColors.muted};--qs-keyword:${defaultColors.keyword};--qs-string:${defaultColors.string};--qs-function:${defaultColors.function};--qs-accent:${defaultColors.accent}`}
	data-themes={JSON.stringify(clientData)}
>
	<div class="theme-strip">
		{themeData.map((theme, i) => (
			<div
				class="theme-swatch"
				style={`background:${theme.swatchBg}`}
				data-theme-index={i}
			>
				<span class="theme-swatch-label">{theme.name}</span>
			</div>
		))}
	</div>

	<p class="theme-description">
		Every color token — accent, borders, tool status, thinking indicators, message
		backgrounds — is fully configurable. Create your own theme as a single JSON file.
	</p>

	<div class="qs-terminal">
		<div class="qs-titlebar">
			<div class="qs-dots"><span></span><span></span><span></span></div>
			<span class="qs-title">QUICK START</span>
		</div>
		<div class="qs-content">
			<div class="qs-line"><span class="qs-prompt">$</span> <span class="qs-cmd">git</span> <span class="qs-fn">clone</span> <span class="qs-str">https://github.com/dungle-scrubs/tallow.git</span></div>
			<div class="qs-line"><span class="qs-prompt">$</span> <span class="qs-cmd">cd</span> <span class="qs-str">tallow</span> <span class="qs-op">{'&&'}</span> <span class="qs-fn">npm</span> <span class="qs-text">install</span> <span class="qs-op">{'&&'}</span> <span class="qs-fn">npm</span> <span class="qs-text">run build</span></div>
			<div class="qs-line"><span class="qs-prompt">$</span> <span class="qs-cmd">node</span> <span class="qs-str">dist/install.js</span></div>
			<div class="qs-line"><span class="qs-prompt">$</span> <span class="qs-str">tallow</span></div>
		</div>
		<div class="qs-accent-bar"></div>
	</div>
</div>

<script>
	/**
	 * Theme preview hover controller.
	 * Swaps CSS custom properties on the .theme-preview container
	 * when hovering over theme swatches in the strip.
	 */
	interface ThemeColorMap {
		bg: string;
		bgDark: string;
		border: string;
		text: string;
		muted: string;
		keyword: string;
		string: string;
		function: string;
		accent: string;
	}

	/** Maps ThemeColorMap keys to their CSS custom property names. */
	const CSS_PROPS: Record<keyof ThemeColorMap, string> = {
		bg: "--qs-bg",
		bgDark: "--qs-bg-dark",
		border: "--qs-border",
		text: "--qs-text",
		muted: "--qs-muted",
		keyword: "--qs-keyword",
		string: "--qs-string",
		function: "--qs-function",
		accent: "--qs-accent",
	};

	const container = document.querySelector<HTMLDivElement>(".theme-preview");

	if (container) {
		const themes: ThemeColorMap[] = JSON.parse(container.dataset.themes ?? "[]");
		const defaultColors = themes[0];

		/**
		 * Applies a resolved color map to the container's CSS custom properties.
		 * @param colors - Hex color map from build-time theme resolution
		 */
		function applyColors(colors: ThemeColorMap): void {
			for (const [key, prop] of Object.entries(CSS_PROPS)) {
				container!.style.setProperty(prop, colors[key as keyof ThemeColorMap]);
			}
		}

		const strip = container.querySelector<HTMLDivElement>(".theme-strip");

		if (strip && defaultColors) {
			for (const swatch of strip.querySelectorAll<HTMLDivElement>(".theme-swatch")) {
				const index = Number(swatch.dataset.themeIndex);
				swatch.addEventListener("mouseenter", () => {
					if (themes[index]) applyColors(themes[index]);
				});
			}
			strip.addEventListener("mouseleave", () => applyColors(defaultColors));
		}
	}
</script>
