---
title: Roadmap
description: What's next for tallow, planned features and direction.
---

import { Aside } from '@astrojs/starlight/components';

Where tallow is headed. These are concrete features in design, not
vague aspirations. Each one has a detailed design document in
the repository.

<div class="roadmap-item" data-status="shipped">
  <div class="roadmap-header">
    <h3>Teams Live Dashboard</h3>
    <span class="roadmap-badge" data-complexity="medium">Medium complexity</span>
    <span class="roadmap-badge" data-status="shipped">Shipped</span>
  </div>
  <div class="roadmap-description">

The [teams extension](/extensions/teams-tool/) now includes a live dashboard
with teammate cards, task board status icons, and a rolling activity feed.
Toggle with `/team-dashboard [on|off|status]`. Wide terminals show tasks and
teammates side-by-side; narrow terminals stack vertically. The dashboard
auto-updates as team state changes and disappears on `team_shutdown`.

  </div>
  <div class="roadmap-meta">
    <span class="roadmap-meta-item"><strong>Extension:</strong> teams</span>
    <span class="roadmap-meta-item"><strong>Command:</strong> /team-dashboard [on|off|status]</span>
  </div>
</div>

<div class="roadmap-item" data-status="planned">
  <div class="roadmap-header">
    <h3>Parallel Plan Execution via Git Worktrees</h3>
    <span class="roadmap-badge" data-complexity="high">High complexity</span>
    <span class="roadmap-badge" data-status="draft">Draft</span>
  </div>
  <div class="roadmap-description">

One plan, N worktrees, N models. Give tallow a task, pick three
models, and it spins up isolated git worktrees, one per
model, all running the same plan in parallel. When they
finish, compare approaches side-by-side: diffs, test results,
token costs, wall-clock time.

This is real model evaluation on your actual codebase. Not
synthetic benchmarks, your code, your constraints, your
judgment on what "better" means.

The system uses two extensions: **worktree-arena** for
orchestration (worktree lifecycle, agent spawning, cleanup)
and an optional **terminal pane provider** (WezTerm, tmux,
Zellij) for visual multi-pane display. Without a display
extension, agents run in the background with log files.

  </div>
  <div class="roadmap-meta">
    <span class="roadmap-meta-item"><strong>Invocation:</strong> tallow plan exec --models claude,gpt-4o,gemini</span>
    <span class="roadmap-meta-item"><strong>Config:</strong> .tallow/plans/*.yaml</span>
    <span class="roadmap-meta-item"><strong>Setup:</strong> .tallow/worktree.yaml</span>
  </div>
</div>

<div class="roadmap-item" data-status="planned">
  <div class="roadmap-header">
    <h3>Unified Plugin System (Claude Code + pi compatible)</h3>
    <span class="roadmap-badge" data-complexity="high">High complexity</span>
    <span class="roadmap-badge" data-status="mostly-shipped">Mostly shipped</span>
  </div>
  <div class="roadmap-description">

One plugin system that understands both ecosystems. tallow
reads from `.claude/` (Claude Code convention) and `.tallow/`
(pi convention) at every level: project-local, user-global,
and system. Both directory trees are scanned, merged at
runtime, and project-local always wins.

Claude Code users bring their existing setup. pi users get
the additional structure pi expects: extensions, prompts,
skills, agents. No migration, no duplication. Drop a command
in `.claude/commands/` or `.tallow/commands/` and it works.

**Claude Code compatibility** maps CC config locations
(`~/.claude/.claude.json`, `.claude/commands/`, `CLAUDE.md`)
into tallow's runtime. Lifecycle hook behavior is supported,
but hook config keys use tallow event names (`tool_call`,
`tool_result`, etc.) rather than automatic `PreToolUse`/
`PostToolUse` key translation. MCP servers declared in tallow
settings register through the mcp-adapter. Slash commands merge
into tallow's command system.

**pi-native paths** add what CC doesn't have: extensions,
typed prompts with subcommands, skills, and agents at the
project level.

**Scopes:**

<ul class="roadmap-checklist">
  <li data-done><strong>Commands.</strong> .tallow/commands/ and .claude/commands/ at project and user levels, via command-prompt extension. Also scans commands/ in local paths listed in settings.json packages.</li>
  <li data-done><strong>Prompts.</strong> .tallow/prompts/ and ~/.tallow/prompts/ natively discovered by pi. Registered as /name slash commands.</li>
  <li data-done><strong>CC Hooks.</strong> hooks.json from packages, extensions, and project/global paths all merged additively. Extension-level hooks.json scanning in ~/.tallow/extensions/*/hooks.json and .tallow/extensions/*/hooks.json. Runtime hooks via hooks:merge event bus.</li>
  <li data-done><strong>CC Context.</strong> CLAUDE.md and AGENTS.md loaded natively by pi from cwd, ancestor directories, and ~/.tallow/. Injected into system prompt automatically. The <a href="/extensions/context-files/">context-files</a> extension supplements this by loading both files when they coexist (pi picks only one) and scanning subdirectories.</li>
  <li data-done><strong>Settings.</strong> .tallow/settings.json deep-merges with ~/.tallow/settings.json via SettingsManager. Project overrides user defaults.</li>
  <li data-done><strong>Hooks.</strong> .tallow/hooks.json and .tallow/settings.json (hooks key) merge with global hooks. Supports standalone files, settings-embedded hooks, and extension-level hooks.json scanning.</li>
  <li data-done><strong>Skills.</strong> .tallow/skills/ discovered natively by pi at project level, layered on top of ~/.tallow/skills/.</li>
  <li data-done><strong>Agents.</strong> .tallow/agents/ discovered at project level by agent-commands and subagent extensions, layered on top of ~/.tallow/agents/.</li>
  <li data-done><strong>Extensions.</strong> .tallow/extensions/ discovered natively by pi at project level, alongside ~/.tallow/extensions/.</li>
</ul>

**Remaining:** `.claude.json` settings passthrough.

  </div>
  <div class="roadmap-meta">
    <span class="roadmap-meta-item"><strong>CC paths:</strong> .claude/&#42;, CLAUDE.md, .claude.json</span>
    <span class="roadmap-meta-item"><strong>pi paths:</strong> .tallow/&#42;, AGENTS.md</span>
    <span class="roadmap-meta-item"><strong>Done:</strong> commands, prompts, CC hooks, context files, settings, hooks, skills, agents, extensions</span>
  </div>
</div>

<div class="roadmap-item" data-status="planned">
  <div class="roadmap-header">
    <h3>Complexity Tiers</h3>
    <span class="roadmap-badge" data-complexity="medium">Medium complexity</span>
    <span class="roadmap-badge" data-status="mostly-shipped">Mostly shipped</span>
  </div>
  <div class="roadmap-description">

Basic model resolution already shipped via the [context-fork](/extensions/context-fork/)
extension — `model: sonnet` resolves to the right Anthropic model ID. What's
next: intent-based tiers that work across providers.

**Shipped: routing keywords and auto-routing.** Agent frontmatter now supports
`model: auto-cheap`, `auto-balanced`, and `auto-premium` — intent-based routing
that picks the best model from available providers based on cost preference. The
task classifier determines type (code/vision/text) and complexity (1-5), then the
model matrix ranks candidates. Per-call hints (`costPreference`, `taskType`,
`complexity`) let the parent LLM override routing for individual invocations.

The bundled `explore` agent uses `auto-cheap` for economical codebase discovery.
See [subagent-tool, routing keywords](/extensions/subagent-tool/#routing-keywords).

**Remaining:** user-facing tier mapping in settings (let users define which of
their models map to `light`/`medium`/`heavy` tiers independently of the matrix).

  </div>
  <div class="roadmap-meta">
    <span class="roadmap-meta-item"><strong>Config:</strong> settings.json or models.json</span>
    <span class="roadmap-meta-item"><strong>Shipped:</strong> Routing keywords (auto-cheap/premium), task classifier, model matrix, per-call hints, bundled explore agent</span>
  </div>
</div>

<div class="roadmap-item" data-status="planned">
  <div class="roadmap-header">
    <h3>Plugin Source Caching &amp; Git Support</h3>
    <span class="roadmap-badge" data-complexity="medium">Medium complexity</span>
    <span class="roadmap-badge" data-status="planned">Planned</span>
  </div>
  <div class="roadmap-description">

The plugin system re-scans all local sources from disk on every session start.
Git sources (`git:github.com/user/plugin@v1.0.0`) warn and skip entirely.

The fix: mtime-based caching for local sources (skip re-scan if unchanged),
immutable caching for pinned git sources (clone once), and TTL-based refresh
for unpinned git sources (1-hour TTL, re-clone when stale).

  </div>
  <div class="roadmap-meta">
    <span class="roadmap-meta-item"><strong>Extension:</strong> plugins</span>
    <span class="roadmap-meta-item"><strong>Cache:</strong> ~/.tallow/plugins-cache/</span>
  </div>
</div>

<div class="roadmap-item" data-status="planned">
  <div class="roadmap-header">
    <h3>Prompt Stash (Ctrl+S)</h3>
    <span class="roadmap-badge" data-complexity="low">Low complexity</span>
    <span class="roadmap-badge" data-status="planned">Planned</span>
  </div>
  <div class="roadmap-description">

`Ctrl+S` stashes the current input. `Ctrl+S` again pops it back
(toggle behavior based on whether input is empty). Stack semantics
with last-in-first-out. In-memory only. Not yet implemented.

  </div>
  <div class="roadmap-meta">
    <span class="roadmap-meta-item"><strong>Extension:</strong> stash-prompt (planned)</span>
    <span class="roadmap-meta-item"><strong>Keybinding:</strong> Ctrl+S (modal toggle)</span>
  </div>
</div>

<div class="roadmap-item" data-status="planned">
  <div class="roadmap-header">
    <h3>Modular Project Rules (.tallow/rules/)</h3>
    <span class="roadmap-badge" data-complexity="medium">Medium complexity</span>
    <span class="roadmap-badge" data-status="mostly-shipped">Mostly shipped</span>
  </div>
  <div class="roadmap-description">

**Shipped: unconditional rules.** The [context-files](/extensions/context-files/)
extension scans three directories: `~/.tallow/rules/` (user global),
`.tallow/rules/` (project), and `.claude/rules/` (CC compatibility). All `.md`
and `.txt` files are discovered and injected into the system prompt at session
start, alongside `AGENTS.md` / `CLAUDE.md` content.

**Remaining: path-scoped rules.** Rules with `paths:` YAML frontmatter that
only inject when the agent reads or edits matching files. This keeps context
lean: API conventions don't pollute frontend work and vice versa.

```markdown
---
paths:
  - "src/api/&#42;&#42;/&#42;.ts"
  - "src/middleware/&#42;&#42;/&#42;.ts"
---
# API Rules
- Validate input with Zod
- Use standard error envelope
- Include OpenAPI JSDoc on every handler
```

Also remaining: `/rules` command to list loaded rules with scope and path
filters, `/rules:add` to create a new rule file, recursive subdirectory
scanning.

  </div>
  <div class="roadmap-meta">
    <span class="roadmap-meta-item"><strong>Extension:</strong> context-files</span>
    <span class="roadmap-meta-item"><strong>Scopes:</strong> ~/.tallow/rules/, .tallow/rules/, .claude/rules/</span>
    <span class="roadmap-meta-item"><strong>Shipped:</strong> Unconditional rules scanning and injection</span>
  </div>
</div>


